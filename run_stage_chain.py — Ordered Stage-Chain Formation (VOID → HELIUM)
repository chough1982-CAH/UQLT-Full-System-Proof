"""
run_stage_chain.py

Executes the ordered stage-chain formation:

VOID → STATIC → RADIO → RADIANT → PLASMA → HELIUM

This script demonstrates that:
- stages emerge only in the correct order
- saturation forces escalation
- no stage can be skipped
- helium formation is an emergent closure event

If the stage chain is violated, execution halts.
"""

import numpy as np

from engine.grid import Grid
from engine.states import State
from engine.transitions import apply_transitions
from config.constants import ENERGY_INTAKE
from config.parameters import (
    STEPS_STAGE_CHAIN,
    RANDOM_SEED,
)

np.random.seed(RANDOM_SEED)


def run_stage_chain():
    grid = Grid()

    for step in range(STEPS_STAGE_CHAIN):
        for i, j in grid.iter_cells():
            state = grid.get_state(i, j)

            # VOID has no intake
            if state == State.VOID:
                continue

            # Intake energy
            delta = ENERGY_INTAKE.get(state.name, 0.0)
            if delta > 0.0:
                grid.add_energy(i, j, delta)

            # Apply lawful transitions
            new_state = apply_transitions(state, grid.get_energy(i, j))
            if new_state != state:
                grid.set_state(i, j, new_state)

        # Seed initial STATIC state at center on step 0
        if step == 0:
            c = grid.center
            grid.set_state(c, c, State.STATIC)

    return grid


if __name__ == "__main__":
    run_stage_chain()
