"""
grid.py

Defines the discrete lattice (grid) used by the UQLT Full-System Proof Engine.

Each cell represents a constrained unit with:
- a discrete state
- a scalar energy value

This module enforces:
- legal state existence
- unit energy capacity limits
- hard failure on overflow or illegal mutation
"""

import numpy as np

from engine.states import State, validate_state
from config.constants import MAX_UNIT_ENERGY
from config.parameters import GRID_SIZE


class Grid:
    """
    Discrete NxN lattice of constrained units.
    """

    def __init__(self, size=GRID_SIZE):
        if size % 2 == 0:
            raise ValueError("GRID_SIZE must be odd to define a center cell.")

        self.size = size

        # State grid
        self.state = np.full((size, size), State.VOID, dtype=object)

        # Energy grid
        self.energy = np.zeros((size, size), dtype=float)

        # Center index
        self.center = size // 2

    # =========================
    # Accessors
    # =========================

    def get_state(self, i, j):
        return self.state[i, j]

    def get_energy(self, i, j):
        return self.energy[i, j]

    # =========================
    # Mutators (Enforced)
    # =========================

    def set_state(self, i, j, new_state):
        validate_state(new_state)
        self.state[i, j] = new_state

        # Reset energy if entering VOID
        if new_state == State.VOID:
            self.energy[i, j] = 0.0

    def add_energy(self, i, j, delta):
        """
        Add energy to a unit and enforce capacity.
        """
        self.energy[i, j] += delta
        self._enforce_capacity(i, j)

    def set_energy(self, i, j, value):
        """
        Set energy directly (used during transitions).
        """
        self.energy[i, j] = value
        self._enforce_capacity(i, j)

    # =========================
    # Enforcement
    # =========================

    def _enforce_capacity(self, i, j):
        """
        Enforce hard unit energy limits.
        """
        state = self.state[i, j]
        max_energy = MAX_UNIT_ENERGY[state.name]

        if self.energy[i, j] > max_energy:
            raise RuntimeError(
                f"Energy overflow at ({i},{j}) | "
                f"state={state.name} | "
                f"energy={self.energy[i, j]:.4f} | "
                f"max={max_energy:.4f}"
            )

        if self.energy[i, j] < 0.0:
            raise RuntimeError(
                f"Negative energy at ({i},{j}) | "
                f"state={state.name} | "
                f"energy={self.energy[i, j]:.4f}"
            )

    # =========================
    # Utilities
    # =========================

    def iter_cells(self):
        """
        Generator over all grid coordinates.
        """
        for i in range(self.size):
            for j in range(self.size):
                yield i, j

    def distance_from_center(self, i, j):
        """
        Euclidean distance from grid center.
        """
        return np.sqrt((i - self.center) ** 2 + (j - self.center) ** 2)
